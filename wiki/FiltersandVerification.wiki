#summary Stop repeating yourself with the use of filters and verifications.
#labels chapter,1.1,draft

If you find the need to run a piece of code before or after several controller actions, then you can use _filters_ to accomplish this without having to explicitly call the code inside each action in question.

This is similar to using the `onRequestStart` / `onRequestEnd` functions in !ColdFusion's `Application.cfc` file, with the difference being that filters tie in better with your Wheels controller setup.

==An Example: Authenticating Users==

One common thing you might find yourself doing is authenticating users before you allow them to see your content. Let's use this scenario to show how to use filters properly. 

You might start out with something like this:

{{{
<cfcomponent extends="Controller">

    <cffunction name="secretStuff">
        <cfif NOT StructKeyExists(session, "userId")>
            <cfabort>
        </cfif>
    </cffunction>

    <cffunction name="evenMoreSecretStuff">
        <cfif NOT StructKeyExists(session, "userId")>
            <cfabort>
        </cfif>
    </cffunction>

</cfcomponent>
}}}

Sure, that works. But you're already starting to repeat yourself in the code. What if the logic of your application grows bigger? It could end up looking like this:

{{{
<cfcomponent extends="Controller">

    <cffunction name="secretStuff">
        <cfif cgi.remote_addr Does Not Contain "212.55">
            <cfset flashInsert(msg="Sorry, we're not open in that area.")>
            <cfset redirectTo(action="sorry")>
        <cfelseif NOT StructKeyExists(session, "userId")>
            <cfset flashInsert(msg="Please login first.")>
            <cfset redirectTo(action="login")>
        </cfif>
    </cffunction>

    <cffunction name="evenMoreSecretStuff">
        <cfif cgi.remote_addr Does Not Contain "212.55">
            <cfset flashInsert(msg="Sorry, we're not open in that area.")>
            <cfset redirectTo(action="sorry")>
        <cfelseif NOT StructKeyExists(session, "userId")>
            <cfset flashInsert(msg="Please login first.")>
            <cfset redirectTo(action="login")>
        </cfif>
    </cffunction>

</cfcomponent>
}}}

Ouch! You're now setting yourself up for a maintenance nightmare when you need to update that IP range or the messages given to the user, etc. One day, you are bound to miss updating it in one of the places.

As the smart coder that you are, you re-factor this to another method so your code ends up like this:

{{{
<cfcomponent extends="Controller">

    <cffunction name="restrictAccess">
        <cfif cgi.remote_addr Does Not Contain "212.55">
            <cfset flashInsert(msg="Sorry, we're not open in that area.")>
            <cfset redirectTo(action="sorry")>
        <cfelseif NOT StructKeyExists(session, "userId")>
            <cfset flashInsert(msg="Please login first!")>
            <cfset redirectTo(action="login")>
        </cfif>
    </cffunction>

    <cffunction name="secretStuff">
        <cfset restrictAccess()>
    </cffunction>

    <cffunction name="evenMoreSecretStuff">
        <cfset restrictAccess()>
    </cffunction>

</cfcomponent>
}}}

Much better! But Wheels can take this process of avoiding repetition one step further. By placing a [filters filters()] call in the `init` method of the controller, you can tell Wheels what function to run before any desired action(s).

{{{
<cfcomponent extends="Controller">

    <cffunction name="init">
        <cfset filters("restrictAccess")>
    </cffunction>

    <cffunction name="restrictAccess">
        <cfif cgi.remote_addr Does Not Contain "212.55">
            <cfset flashInsert(msg="Sorry, we're not open in that area.")>
            <cfset redirectTo(action="sorry")>
        <cfelseif NOT StructKeyExists(session, "userId")>
            <cfset flashInsert(msg="Please login first!")>
            <cfset redirectTo(action="login")>
        </cfif>
    </cffunction>

    <cffunction name="secretStuff">
    </cffunction>

    <cffunction name="evenMoreSecretStuff">
    </cffunction>

</cfcomponent>
}}}

Besides the advantage of not having to call `restrictAccess()` twice, you have also gained two other things:

 * The developer coding `secretStuff()` and `evenMoreSecretStuff()` can now focus on the main tasks of those two methods without having to worry about site-wide logic like authentication.
 * The `init()` method is now starting to act like an overview for the entire controller.

All of these advantages will become much more obvious as your applications grow. This was just a simple example to put filters into context.

==Sharing Filters Between Controllers==

So far, we've only been dealing with one controller. Unless you're building a very simple website, you'll end up with a lot more.

The question then becomes, "Where do I place the `restrictAccess()` function so I can call it from any one of my controllers?" The answer is that because all controllers extend `Controller.cfc`, you should probably put it there. The `init()` method itself with the call to [filters filters()] should remain inside your individual controllers though.

If you actually want to set the same filters to be run for all controllers, you can go ahead and move it to the `Controller.cfc` file's `init()` method as well. Keep in mind that if you want to run the `init()` method in the individual controller *and* in `Controller.cfc`, you will need to call `super.init()` from the `init()` method of your individual controller.

==Passing Arguments to Filter Functions==

Sometimes it's useful to be able to pass through arguments to the filters (for one, it can help you reduce the amount of functions you need to write). Here's the easy way to pass through an argument:

{{{
<cfset filters(through="authorize", byIP=true)>
}}}

Now the `byIP` argument will be available in the `authorize` function.

Hard-coded variables like that pose no issues but you have to remember that since the `init` function doesn't run on every request you can't start passing through `URL`, `form` or `request` scoped variables for example. What would happen is that it would only evaluate that variable once and then pass that same value through on all subsequent requests. Probably not what you wanted.

There is a way around this limitation though and that is to delay the evaluation of the variable so it evaluates on each request instead of just once. here's how you can pull that off:

{{{
<cfset filters(through="authorize", byIP=true, region="##request.region##")>
}}}

Now, instead of evaluating `request.region` inside the `init` function it will be done as it gets passed through to the `authorize` function on each request instead.

To avoid any clashing of variables Wheels also supports passing in the arguments in a struct as well:

{{{
<cfset args.byIP = true>
<cfset args.through = true>
<cfset filters(through="authorize", authorizeArguments=args)>
}}}

==2 Types of Filters==

The example with authentication showed a "before filter" in action. The other type of filter you can run is an "after filter." As you can tell from the name, an after filter executes code after the action has been completed.

This can be used to make some last minute modifications to the HTML before it is sent to the browser (think translation, compression, etc.), for example.

If you want to get a copy of the content that will be rendered to the browser from an after filter you can use the [response response()] function. Let's say you want to quickly translate the content to Gibberish before sending it to your visitor you can do something like this:

{{{
<cffunction name="init">
  <cfset filters(through="translate", type="after")>
</cffunction>

<cffunction name="translate">
  <cfset setResponse(gibberify(response()))>
</cffunction>
}}}

You specify if you want to run the filter function before or after the controller action with the `type` argument to the [filters filters()] function. It defaults to running it before the action.

==Including and Excluding Actions From Executing Filters==

By default, filters apply to all actions in a controller. If that's not what you want, you can tell Wheels to only run the filter on the actions you specify with the `only` argument. Or you can tell it to run the filter on all actions except the ones you specify with the `except` argument).

Here are some examples showing how to setup filtering in your controllers. Remember, these calls go inside the `init` function of your controller file.

{{{
<cfset filters(through="isLoggedIn,checkIPAddress", except="home,login")>
<cfset filters(through="translateText", only="termsOfUse", type="after")>
}}}

==Low Level Access==

If you need to access your filters on a lower level so to speak you can do so by using the [filterChain filterChain()] and [setFilterChain setFilterChain()] functions. Typically you'll want to call [filterChain filterChain()] to return an array of all the filters set on the current controller and then make your desired changes and save it back using the [setFilterChain setFilterChain()] function.

==So What's Verification Then?==

Verification, through the [verifies verifies()] function, is just a special type of filter that runs before actions. Its capability is limited; the only thing you can do is verify the request method (`post` or `get`), whether it's an AJAX request, whether specified variables exist and if it is of a certain type.

Let's say that you want to make sure that all requests coming to a page that handles form submissions are `post` requests. While you can do this with a filter, it is more convenient to do it with the [verifies verifies()] function.

All that you need to do is this:

{{{
<cfset verifies(only="handleForm", post=true)>
}}}

The code above will ensure that all requests coming to the `handleForm` function are from form submissions. All other requests will be aborted. You can also specify different behavior for when the verification fails in a special handler function.

A very convenient and common use is when you want to make sure that a variables exists and it is of a certain type otherwise redirect the user to a different page. Step back in time for a moment and remember how you use to code websites before Wheels (yes I know those were dark days, but stay with me).

On your edit.cfm page what you probably did was write some code at the top of that looked like this:

{{{
<cfif !StructKeyExists(form, "userid") OR !IsValid("guid", form.userid)>
  <cflocation url="index.cfm" addToken="false">
</cfif>
}}}

With this snippet of code you could ensure that any request to the edit.cfm had to have the userid in the form scope and that userid had to be guid. If these conditions weren't met, the request was redirected to the index.cfm page. This was a very time consuming, but necessary task.

Now let's see how using the [verifies verifies()] function within Wheels to improve this:

{{{
<cfset verifies(only="edit", post=true, params="userid", paramsTypes="guid", action="index", error="Invalid user id.")>
}}}

With that one line of code, Wheels will perform the following checks when a request is made to the controller's edit action:

* it will make sure that the request is a `post` request
* it will make sure that the userid variables exists in the params struct
* it will make sure that the params.userid is a guid datatype.

If any of those checks fail, Wheels will redirect the request to the index action of the controller and place an error key in the flash containing the message "Invalid user id". All that functionality and security in only one line of code!

Hold on a sec... What if you wanted do this to two or more variables? Well dear developer, the params and paramsTypes take a list so you can include as many variables to check against as you want. The only thing you need to make sure of is that the number of variables in the `params` list matches the number types to check against in the `paramsTypes` list. This also goes for the session / sessionTypes and cookie / cookieTypes. 

You can read more in the documentation for the [verifies verifies()] function. 