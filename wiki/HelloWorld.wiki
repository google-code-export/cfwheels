#summary This is the obligatory Hello World tutorial.
#labels chapter,1.0,draft

In this tutorial, we'll be writing a simple application to make sure we have Wheels installed properly and that everything is working as it should. Along the way, you'll get to know some basics about how applications built on top of Wheels work.

==Testing Your Install==

Let's make sure we're all on the same page. I'm going to assume that you've already [http://cfwheels.org/download downloaded the latest version of Wheels] and have it installed on your system. If you haven't done that, stop and read the [Installation Installation] chapter and get everything setup. It's okay, this web page will wait for you.

Okay, so you have Wheels installed and can see the Wheels "Congratulations!" page as shown in _Figure 1_ below. That wasn't that hard now, was it?

http://cfwheels.googlecode.com/files/wheels-1.0-congratulations-screen.jpg

_Figure 1: Wheels congratulations screen._

==The Role of MVC in Wheels==

Imagine a football team where everyone tries to be quarterback. Things would get pretty messy rather quickly. On a football team, or any team for that matter, each member should have a specific job and responsibility.

Wheels helps clean up this mess by using a design pattern called _Model-View-Controller (MVC)_. Let's take a brief look at MVC and see how it helps organize your Wheels applications.

At a basic level, a MVC framework like Wheels breaks your application into 3 distinct pieces, each having a well-defined role and responsibility. The 3 pieces are called models, views and controllers. Pretty intuitive so far, eh?

===Model Layer===

The *model* is responsible for the data objects of your application. In general, models interact with your databases and contain any specific business rules that tell your applications how to use that data.

===View Layer===

The *view* is responsible for the user interface, or presentation layer, of your application. Views build and present the web pages and other interface elements that make up your application.

===Controller Layer===

The *controller* is the central command of your application. Controllers define and know about the functions or actions that your application can handle. These actions are generally the web requests initiated by the users by invoking URLs. A controller's job is to listen for these actions, interact with the model to get any data that is needed by the action, and then finally hand off the data to the view so it can display a page for the user.

Others have written entire volumes describing the MVC pattern and its pros and cons. Some of these books are great reads, but this high level understanding of MVC should be all that you need in order to get starting using Wheels.

==URLs in Wheels==

Wheels handles three different classes of URLs depending on the capabilities of your web server. The most basic form is No URL Rewriting, then Partial URL Rewriting, and finally Full URL Rewriting. Wheels will attempt to determine what level of URL Rewriting your server supports and automatically configure your application to use the most advanced level of URL Rewriting your server environment allows. So lets take a look at each class of URLs that Wheels supports.

===No URL Rewriting===

This is the most basic form of URLs that Wheels handles. There is really nothing special about this since its what we are all used to. The URLs make use of a single file that all requests are routed through and specifically pass all the variables and values in the query string. Lets take a look at an example URL in this format:

{{{
http://www.mydomain.com/index.cfm?controller=say&action=hello
}}}

Now lets break this apart and see what is going on. There really is no magic here, we first specify the protocol to use, in this case {{{http}}}, then we specify the domain name, here we are using a dummy domain {{{www.mydomain.com}}}, then we specify the file to call {{{index.cfm}}}. Up to this point there is nothing new going on, we've seen this all before. Now we start telling Wheels what we want it to do, we specify that we want to call the *say* controller using {{{controller=say}}} and finally we indicate that we want to invoke the *hello* action of the say controller using {{{action=hello}}}.

This is the most basic form of URLs that Wheels can handle. It will work on all web servers and doesn't require you to configure anything special for it to work. It's ugly but it works...now lets see how we can clean these URLs up a bit.
 
===Partial URL Rewriting===

The next class of URLs that we should look at are what we call Partial URL Rewriting. With Partial rewriting we get rid of all the special characters in the URL. All the `?` and `&` are removed and even the `controller=` and `action=` are removed from the URL. So lets take a look at what the above URL would look like in Partial Rewriting form.

{{{
http://www.mydomain.com/index.cfm/say/hello
}}}

As you can see this form of URLs are much cleaner. We've trimmed off most of the unnecessary pieces of the URL. What remains is the protocol, domain, and file like before, but now we sprinkle some Wheels magic. The next item on the URL is the controller in this case {{{say}}} and finally the action to invoke in that controller which in this case is {{{hello}}}. 

Here is where we start depending on some server capabilities though. In order for partial URLs to work, your server environment must support Path Info.Typically this means that the Servlet Engine you are using for your CFML engine must support Path Info. A server that supports the Path Info variable will take whatever was on the query string beyond the file name, in the example above {{{/say/hello}}}, and make it available to the application by passing it in the cgi variable path_info. That is how Wheels knows what controller and action you want to call. Unfortunately this information is not always passed along. For example the Jetty servlet engine does not support Path info so if you use the Railo Express server you will not be able to get Partial URLs to work. The easiest way to see if your server supports passing Path Info information is to put the following code on a page and see if it contains the additional URL information.

{{{
<cfoutput>#cgi.path_info#</cfoutput>
}}}
 
===Full URL Rewriting===

The built-in URL rewriting functionality of Wheels helps you create friendly, search engine safe URLs. No more are the days of URLs polluted with question marks, ampersands, and equals signs!

Consider the URL below:

{{{
http://www.example.com/say/hello
}}}

Like all URLs that you're familiar with, the `http://www.example.com/` portion of the URL defines the domain or server name of your application. This portion is similar to any other URL on the Web. Really not much to see here, so let's move on.

The next portion is where the magic happens.

In other !ColdFusion frameworks, we're used to seeing variables separated by `?` and `&`. With Fusebox, for example, we'd probably see a URL like `http://www.example.com/index.cfm?fuseaction=say.hello`. Yuck.

Wheels, on the other hand, uses _URL rewriting_. Instead of specifying variables by separating them with `?` and `&`, the different variables are passed to the application as folder names.

Our example URL defines which components and methods within the application get called by the URL. The example URL above tells our application to execute the `say` controller and call the `hello` action within that controller. So this is how the URL of a Wheels application maps to the parts of the MVC pattern described above.

==Hello World: Your First Wheels App==

Okay, let's get to some example code. We know that you've been dying to get your hands on some code!

To continue with programming tutorial tradition, we'll create the ubiquitous _Hello World!_ application. But to keep things interesting, let's add a little Wheels magic along the way.

===Setting up the Controller===

Let's create a controller from scratch to illustrate how easy it is to set up a controller and plug it into the Wheels framework.

First, create a file called `Say.cfc` in the `controllers` directory and add the code below to the file.

{{{
<cfcomponent extends="Controller">
</cfcomponent>
}}}

Congratulations, you just created your first Wheels controller! What does this controller do, you might ask? Well, to be honest, not much. It has no functions defined so it doesn't add any new functionality to our Wheels application. But because it extends the base `Controller` component, it inherits quite a bit of powerful functionality and is now tied into our Wheels application.

So what happens if we try to call our new controller right now? Lets take a look! Open your browser and point your browser to the new controller. Do this by simply entering `http://localhost/say` in your browser of choice. You may need to enter a different URL, depending on how your web server is configured.

If you did everything right, you will get the Wheels error shown below in _Figure 2_. (Ironic that getting an error is doing something right, huh? Don't get used to it, buddy!)

http://cfwheels.googlecode.com/files/wheels-0.9.4-no-view-error-screen.jpg

_Figure 2: Wheels error after setting up your blank `say` controller._

The error says "Could not find the view page for the 'index' action in the 'say' controller." Where did "index" come from? The URL we typed in only specified a controller name but no action. When an action is not specified in the URL, Wheels assumes that we want the _default action_. Out of the box, the default action in Wheels is set to `index`. So in our example, Wheels tried to find the `index` action within the `say` controller, and it threw an error because it couldn't find its view page.

===Setting up an Action===

But let's jump ahead. Now that we have the controller created, let's add an action to it called `hello`. Change your `say` controller so it looks like the code block below:

{{{
<cfcomponent extends="Controller">

    <cffunction name="hello">
    </cffunction>

</cfcomponent>
}}}

As you can see, we created an empty function named `hello`.

Now let's call our new action in the browser and see what we get. To call the `hello` action we simply add `/hello` to the end of the previous URL that we used to call our `say` controller:

{{{
http://localhost/say/hello
}}}

Once again, we get the same !ColdFusion error. Although we have created the controller and added the `hello` action to it, we haven't created the _view_.

===Setting up the View===

By default, when an action is called, Wheels will look for a view file with the same name as the action. It then hands off the processing to the view to display the user interface. In our case, Wheels tried to find a view file for our `say/hello` action and couldn't find one.

Let's remedy the situation and create a view file. View files are simple CFML pages that handle the output of our application. In most cases, views will return HTML code to the brower. By default, the view files will have the same name as our controller actions and will be grouped into a directory under the `views` directory. This new directory will have the same name as our controller.

Find the `views` directory in the root of your Wheels installation. There will be a few directories and files in there already. For now, we need to create a new directory in the `views` directory called `say`. This is the same name as the controller that we created above.

Now inside the `say` directory, create a file called `hello.cfm`. In the `hello.cfm` file, add the following line of code:

{{{
<h1>Hello World!</h1>
}}}

Save your `hello.cfm` file, and let's call our `say/hello` action once again. You have your first working Wheels page if your browser looks like _Figure 3_ below.

http://cfwheels.googlecode.com/files/wheels-0.9.4-hello-world-screen.jpg

_Figure 3: Your first working Wheels action._

You have just created your first functional Wheels page, albeit it is a very simple one. Pat yourself on the back, go grab a snack, and when you're ready, let's go on and extend the functionality of our _Hello World!_ application a little more.

Oh, and by the way, if you think this was a lot of work just for creating one page then you should know that you can actually delete the entire `Say.cfc` file and it will still work (as long as the `say/hello.cfm` file is still there Wheels will find it and display it for you regardless of whether you have a corresponding controller file or not).

==Adding Dynamic Content to Your View==

We will add some simple dynamic content to our `hello` action and add a second action to the application. We'll then use some Wheels code to tie the 2 actions together. Let's get get to it!

===The Dynamic Content===

The first thing we are going to do is to add some dynamic content to our `say/hello` action. Modify your say controller so it looks like the code block below:

{{{
<cfcomponent extends="Controller">
	
    <cffunction name="hello">
        <cfset time = Now()>
    </cffunction>

</cfcomponent>
}}}

All we are doing here is creating a variable called `time` and setting its value to the current server time using the basic !ColdFusion `Now()` function. When we do this, the variable becomes immediately available to our view code.

Why not just set up this value directly in the view? If you think about it, maybe the logic behind the value of `time` may eventually change. What if eventually we want to display its value based on the user's time zone? What if later we decide to pull it from a web service instead? Remember, the controller is supposed to coordinate all of the data and business logic, not the view.

===Displaying the Dynamic Content===

Next, we will modify our `say/hello.cfm` view file so that it looks like the code block below. When we do this, the value will be displayed in the browser.

{{{
<h1>Hello World!</h1>
<p>Current time: <cfoutput>#time#</cfoutput></p>
}}}

Now call your `say/hello` action again in your browser. Your browser should look like _Figure 4_ below.

http://cfwheels.googlecode.com/files/wheels-0.9.4-hello-world-dynamic-screen.jpg

_Figure 4: Hello World with the current date and time._

This simple example showed that any dynamic content created in a controller action is available to the corresponding view file. In our application, we created a `time` variable in the `say/hello` controller action and display that variable in our `say/hello.cfm` view file.

===Adding a Second Controller: Goodbye===

Now we will expand the functionality of our application once again by adding a second action to our `say` controller. If you feel adventurous, go ahead and add a `goodbye` action to the `say` controller on your own, then create a `goodbye.cfm` view file that displays a "Goodbye" message to the user. If you're not feeling that adventurous, we'll quickly go step by step.

First, modify the the `say` controller file so that it looks like the code block below.

{{{
<cfcomponent extends="Controller">

    <cffunction name="hello">
        <cfset time = Now()>
    </cffunction>

    <cffunction name="goodbye">
    </cffunction>

</cfcomponent>
}}}

Now go to the `views/say` directory and create a `goodbye.cfm` page.

Add the following code to the `goodbye.cfm` page and save it.

{{{
<h1>Goodbye World!</h1>
}}}

If we did everything right, we should be able to call the new say/goodbye action using the following URL:

{{{
http://localhost/say/goodbye
}}}

Your browser should look like _Figure 5_ below:

http://cfwheels.googlecode.com/files/wheels-0.9.4-goodbye-world-screen.jpg

_Figure 3: Your new `goodbye` action._

===Linking to Other Actions===

Now let's link our two actions together. We will do this by adding a link to the bottom of each page so that it calls the other page.

====Linking Hello to Goodbye====

Open the `say/hello.cfm` view file. We are going to add a line of code to the end of this file so our `say/hello.cfm` view file looks like the code block below:

{{{
<h1>Hello World!</h1>
<p>Current time: <cfoutput>#time#</cfoutput></p>
<p>Time to say <cfoutput>#linkTo(text="goodbye", action="goodbye")#?</cfoutput></p>
}}}

The [linkTo linkTo()] function is a built-in Wheels function. In this case, we are passing 2 named parameters to it. The first parameter, `text`, is the text that will be displayed in the hyperlink. The second parameter, `action`, defines the action to point the link to. By using this built-in function, your application's main URL may change, and even controllers and actions may get shifted around, but you won't suffer from the dreaded dead link. Wheels will always create a valid link for you as long as you configure it correctly when you make infrastructure changes to your application.

Once you have added the additional line of code to the end of the `say/hello.cfm` view file, save your file and call the `say/hello` action from your browser. Your browser should look like _Figure 6_ below.

http://cfwheels.googlecode.com/files/wheels-0.9.4-hello-world-linked-screen.jpg

_Figure 6: Your `say/hello` action with a link to the `goodbye` action._

You can see that Wheels created a link for us and added an appropriate URL for the `say/goodbye` action to the link.

====Linking Goodbye to Hello====

Let's complete our little app and add a corresponding link to the bottom of our `say/goodbye.cfm` view page.

Open your `say/goodbye.cfm` view page and modify it so it looks like the code block below.

{{{
<h1>Goodbye World!</h1>
<p>Time to say <cfoutput>#linkTo(text="hello", action="hello")#?</cfoutput></p>
}}}

If you now call the goodbye action in your browser, your browser should look like figure 7 below.

If you now call the say/goodbye action in your browser, your browser should look like Figure 7 below.

http://cfwheels.googlecode.com/files/wheels-0.9.4-goodbye-world-linked-screen.jpg

_Figure 7: Your `say/goodbye` action with a link to the `hello` action._

==Much More to Learn==

You now know enough to be dangerous with !ColdFusion on Wheels. Look out! But there are many more powerful features to cover. You may have noticed that we haven't even talked about the M in MVC.

No worries. We will get there. And we think you will enjoy it.