#summary Save data in associated model objects through the parent.
#labels chapter,draft,1.1

When you're starting out as a Wheels developer, you are probably amazed at the simplicity of a model's CRUD methods. But then it all gets quite a bit more complex when you need to update records in multiple database tables in a single transaction.

_Nested properties_ in Wheels makes this scenario dead simple. With a configuration using `nestedProperties()` in your model, you can save changes to that model and associated models in a single call to `save()`, `create()`, and `update()`.

== One-to-One Relationships with Nested Properties ==

Consider a `user` model that has one `profile`:

{{{
<!--- models/User.cfc --->
<cfcomponent extends="Model">

    <cffunction name="init">
        
        <cfset hasOne("profile")>
        <cfset nestedProperties(associations="profile", autoSave=true, allowDelete=true)>

    </cffunction>

</cfcomponent>
}}}

By adding the call to `nestedProperties()` in the above example, you can create both the `user` object and the `profile` object in one call to `create()`. Setting `autoSave` to `true` allows this functionality to happen.

{{{
<cfset params.user = {firstName="Russ", lastName="Johnson"}>
<cfset params.user.profile = {twitterHandle="russ_johnson"}>
<cfset user = model("user").create(params.user)>

<cfoutput>
    #user.profile.id# <!--- Outputs "2" --->
    #user.profile.twitterHandle# <!--- Outputs "russ_johnson" --->
</cfoutput>
}}}

You can also save changes to the child `profile` through the parent `user` object:

{{{
<cfset user = model("user").findByKey(key=45, include="profile")>
<cfset user.profile.twitterHandle = "CFonWheels">
<cfset user.save()>

<cfoutput>
    #user.profile.twitterHandle# <!--- Outputs "CFonWheels" --->
</cfoutput>
}}}

By passing `allowDelete=true` to the `nestedProperties()` call above, you are also delete the `user`'s related `profile` by setting a property called `_delete`:

{{{
<cfset user.profile._delete = true>
<cfset user.save()>

<!--- Would output "0" --->
<cfoutput>
    #user.profile(returnAs="query").RecordCount#
</cfoutput>
}}}


The `autoSave` and `allowDelete` arguments are both optional and default to `false`, so you must "opt in" to these capabilities when setting up your nested properties.

== Many-to-Many Relationships with Nested Properties ==

Consider the many-to-many associations related to `customer`s, `publication`s, and `subscription`s from the [Associations] chapter.

{{{
<!--- models/Customer.cfc --->
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset hasMany(name="subscriptions", shortcut="publications")>
    </cffunction>

</cfcomponent>
}}}
{{{
<!--- models/Publication.cfc --->
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset hasMany("subscriptions")>
    </cffunction>

</cfcomponent>
}}}
{{{
<!--- models/Subscription.cfc --->
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset belongsTo("customer")>
        <cfset belongsTo("publication")>
    </cffunction>

</cfcomponent>
}}}

When it's time to save `customer`s' subscriptions in the `subscriptions` join table, one approach is to loop through data submitted by `checkBoxTag()`s, populate `subscription` model objects with the data, and call `save()`. This approach is valid, but there is a simpler way.

With some simple model configurations and form helpers, you can simplify complex database transactions to a few lines of code and let Wheels do the rest!

== Setting up Nested Properties in Your Model ==

In this case, let's define the nested properties in your model's `init()` method with the `nestedProperties()` method. Using the `customer` model from the example above, let's say that we want to allow our Wheels application to automatically save and delete related `subscription` objects based on form submissions (more on the form part later).

We would set it up in `init()` like so:

{{{
<!--- models/Customer.cfc --->
<cfcomponent extends="Model">

    <cffunction name="init">
        <!--- Associations --->
        <cfset hasMany(name="subscriptions", shortcut="publications")>
        <!--- Nested properties --->
        <cfset nestedProperties(associations="subscriptions", autoSave=true, allowDelete=true)>
    </cffunction>

</cfcomponent>
}}}

With this set of nested properties defined, the `customer` model now has some extra behaviors enabled:
 * `customer` will now accept one or many values for a property called `subscriptions`.
 * `customer` will automatically save the value(s) when there are changes.
 * `customer` will automatically delete the value(s) marked for deletion through a key called `_delete`.

== Building a Form with Nested Properties ==

With the nested properties configured in the model, we can now build a series of check boxes that will allow the end user to associate many `subscriptions` with the `customer`.

First, let's define the data needed in an `edit` action in the controller at `controllers/Customers.cfc`. For the view, we need to pull the `customer` with its associated `subscriptions` included with the `include` argument. We also need all of the publications in the system for the user to choose from.

{{{
<cffunction name="edit">

    <cfset customer = model("customer").findByKey(key=params.key, include="subscriptions")>
    <cfset publications = model("publication").findAll(order="title")>

</cffunction>
}}}

Now the view template at `views/customers/edit.cfm` is where the magic happens. In this view, we will have a form for editing the `customer` and check boxes for selecting the `customer`'s `subscription`s.

{{{
<cfparam name="customer">
<cfparam name="publications" type="query">

<cfoutput>

#errorMessagesFor("customer")#

#startFormTag(action="update")#

<fieldset>
    <legend>Customer</legend>

    #textField(label="First Name", objectName="customer", property="firstName")#
    #textField(label="Last Name", objectName="customer", property="lastName")#
    #textField(label="Address 1", objectName="customer", property="address1")#
    #textField(label="Address 2", objectName="customer", property="address2")#
    #textField(label="City", objectName="customer", property="city")#
    #textField(label="State", objectName="customer", property="state")#
    #textField(label="Zip", objectName="customer", property="zip")#
</fieldset>

<fieldset>
    <legend>Subscriptions</legend>

    <cfloop query="publications">
        #hasManyCheckBox(label=publications.title, objectName="customer", association="subscriptions", keys="#customer.key()#,#publications.id#")#
    </cfloop>
</fieldset>

<div>
    #hiddenField(objectName="customer", value="id")#
    #submitTag()#
</div>

#endFormTag()#

</cfoutput>
}}}

The main point of interest in this example is the `<fieldset>` for Subscriptions, which loops through the query of `publications` and uses the `hasManyCheckBox()` form helper. This helper is similar to `checkBox()` and `checkBoxTag()`, but it is specifically designed for building form data related by associations.

Notice that the `objectName` argument passed to `hasManyCheckBox()` is the parent `customer` object and the `associations` argument contains the name of the related association. Wheels will build a form variable named in a way that the `customer` object is automatically bound to the `subscriptions` association.

The `keys` argument accepts the foreign keys that should be associated together in the `subscriptions` join table. Note that these keys should be listed in the order that they appear in the related database table. In this example, the `subscriptions` table in the database contains composite primary key columns called `customerid` and `publicationid`, in that order.

== How the Form Submission Works ==

Handling the form submission is the most powerful part of the process, yet it involves no extra effort on your part. You'll notice that this example `update` action is fairly standard for a Wheels application:

{{{
<cffunction name="update">

    <!--- Load customer object --->
    <cfset customer = model("customer").findByKey(params.customer.id)>
    <!--- If update is successful, generate success message and redirect back to edit screen --->
    <cfif customer.update(params.customer)>
        <cfset flashInsert(success="#customer.firstName# #customer.lastName# record updated successfully.")>
        <cfset redirectTo(action="edit", key=customer.id)>
    <!--- If update fails, show form with errors --->
    <cfelse>
        <cfset renderPage(action="edit")>
    </cfif>

</cffunction>
}}}

In fact, there is nothing special about this. But with the nested properties defined in the model, Wheels handles quite a bit when you save the parent object:
 * Wheels will update the `customers` table with any changes submitted in the Customers `<fieldset>`.
 * Wheels will add and remove records in the `subscriptions` table depending on which check boxes are selected by the user in the Subscriptions `<fieldset>`.
 * All of these database queries will be wrapped in a [Transactions transaction]. If any of the above updates don't pass validation or if the database queries fail, the transaction will roll back.
 * The `customer` object will collect validation errors for the whole transaction. All of these errors will be shown by the `errorMessagesFor()` view helper on the form.