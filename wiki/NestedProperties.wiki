#summary Save data in associated model objects through the parent.
#labels chapter,draft,1.1

When you're starting out as a Wheels developer, you are probably amazed at the simplicity of a model's CRUD methods. But then it all gets quite a bit more complex when you need to update records in multiple database tables in a single transaction.

_Nested properties_ in Wheels makes this scenario dead simple. With a configuration using the `nestedProperties()` function in your model's `init()` method, you can save changes to that model and its associated models in a single call with `save()`, `create()`, or `update()`.

== One-to-One Relationships with Nested Properties ==

Consider a `user` model that has one `profile`:

{{{
<!--- models/User.cfc --->
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset hasOne("profile")>
        <cfset nestedProperties(associations="profile", autoSave=true, allowDelete=true)>
    </cffunction>

</cfcomponent>
}}}

By adding the call to `nestedProperties()` in the model, you can create both the `user` object and the `profile` object in a single call to `create()`. Setting `autoSave` to `true` allows for this functionality to happen.

=== Setting up Data for the `user` Form ===

First, in our controller, let's set the data needed for our form:

{{{
<!--- In controllers/User.cfc --->
<cffunction name="new">
    <cfset user = model("user").new()>
</cffunction>
}}}

All that we need to do here is call `new()` on the `user` model.

Note that if this were an `edit` action calling an existing object, our call would need to look similar to this:

{{{
<!--- In controllers/User.cfc --->
<cffunction name="edit">
    <cfset user = model("user").findByKey(key=params.key, include="profile")>
</cffunction>
}}}

Because the form will also expect data set in the `profile` property, you must include that association in the finder call.

=== Building a Form for Posting Nested Properties ===

For this example, our form at `views/users/new.cfm` will end up looking like this:

{{{
#startFormTag(action="create")#

    <!--- Data for `user` model --->
    #textField(label="First Name", objectName="user", property="firstName")#
    #textField(label="Last Name", objectName="user", property="lastName")#

    <!--- Data for associated `profile` model --->
    #textField(label="Twitter Handle", objectName="user", association="profile", property="twitterHandle")#
    #textArea(label="Biography", objectName="user", association="profile", property="bio")#

    <div>#submitTag(value="Create")#</div>

#endFormTag()#
}}}

Of note are the calls to form helpers for the `profile` model, which contain an extra argument for `association`. This argument is available for all object-based form helpers. By using the `association` argument, Wheels will name the form field in such a way that the properties for the `profile` will be nested within an object in the `user` model.

Take a minute to read that last statement again. OK, let's move on to the action that handles the form submission.

=== Saving the Object and Its Nested Properties ===

You may be surprised to find out that our standard `create` action does not change at all from what you're used to.

{{{
<!--- In controllers/Users.cfc --->
<cffunction name="create">
    <cfset user = model("user").new(params.user)>
    <cfif user.save()>
        <cfset flashInsert(success="The user was created successfully.")>
        <cfset redirectTo(controller=params.controller)>
    <cfelse>
        <cfset renderPage(action="new")>
    </cfif>
</cffunction>
}}}

When calling `user.save()` in the example above, Wheels takes care of the following:

 * Saves the data passed into the `user` model.
 * Sets a property on `user` called `profile` with the profile data stored in an object.
 * Saves the data passed into that `profile` model.
 * Wraps all calls in a transaction in case validations on any of the objects fail or something wrong happens with the database.

For the edit scenario, this is what our `update` action would look like (which is very similar to `create`:

{{{
<!--- In controllers/Users.cfc --->
<cffunction name="update">
    <cfset user = model("user").findByKey(params.user.id)>
    <cfif user.update(params.user)>
        <cfset flashInsert(success="The user was updated successfully.")>
        <cfset redirectTo(action="edit")>
    <cfelse>
        <cfset renderPage(action="edit")>
    </cfif>
</cffunction>
}}}

== Deleting a Child Object ==

By passing `allowDelete=true` to the `nestedProperties()` call in the model, you can also delete the `user`'s related `profile` by setting a property called `_delete` on it:

{{{
<cfset user.profile._delete = true>
<cfset user.save()>

<!--- Would output "0" --->
<cfoutput>
    #user.profile(returnAs="query").RecordCount#
</cfoutput>
}}}

The `autoSave` and `allowDelete` arguments are both optional and default to `false`, so you must "opt in" to these capabilities when setting up your nested properties.

== One-to-Many Relationships with Nested Properties ==

Nested properties work with one-to-many associations as well, except now the nested properties will contain an array of objects instead of a single one.

In the `user` model, let's add an association called `addresses` and also enable it as nested properties.

{{{
<!--- models/User.cfc --->
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset hasOne("profile")>
        <cfset hasMany("addresses")>
        <cfset nestedProperties(associations="profile,addresses", autoSave=true, allowDelete=true)>
    </cffunction>

</cfcomponent>
}}}

In this example, we have added the `addresses` association to the call to `nestedProperties()`, thus enabling `autoSave` and `allowDelete`.

=== Building the Form for the One-to-Many Association ===

This time, we'll add a section for addresses on our form with a little !JavaScript that allows for multiple addresses to be entered. (To keep the example simpler, let's omit the `profile` association from the earlier example.)

{{{
<!--- jQuery code that would probably be included by `javaScriptIncludeTag()` --->
<script type="text/javascript">
(function($){
    $(document).ready(function(){
        // Address container
        var address = $("#address");

        // Add "+ Add Address" link after addresses div
        address.after('<a id="add-address-link">+ Add Address</a>');
        
        // Copy a new blank address on click of "+ Add Address" link
        $("#add-address-link").click(function(){
            var firstAddressCopy = $("#addresses .address").first().clone();
            address.append(firstAddressCopy);
            // TODO: Finish this script when I'm less tired
        });
    });
})(jQuery);
</script>

#startFormTag(action="create")#

    <!--- Data for `user` model --->
    <fieldset>
        <legend>User</legend>

        #textField(label="First Name", objectName="user", property="firstName")#
        #textField(label="Last Name", objectName="user", property="lastName")#
    </fieldset>

    <!--- Data for `address` models --->
    <fieldset>
        <legend>Addresses</legend>

        <div id="addresses">
            <div class="address">
                #textField(label="Street", objectName="user", association="addresses", position=1, property="address1")#
                #textField(label="City", objectName="user", association="addresses", position=1, property="city")#
                #textField(label="State", objectName="user", association="addresses", position=1, property="state")#
                #textField(label="Zip", objectName="user", association="addresses", position=1, property="zip")#
            </div>
        </div>
    </fieldset>

    <div>#submitTag(value="Create")#</div>

#endFormTag()#
}}}

Because there can be multiple addresses on the form, the form helpers accept an additional argument for `position`. Without having a unique position identifier for each `address`, Wheels would have no way of understanding which `state` field matches with which particular `address`.

=== Auto-saving a Collection of Child Objects ===

Even with a complex form with a number of child objects, Wheels will save all of the data through its parent's `save()`, `update()`, or `create()` methods.

Here, we save the `user` model, which will take care of all of the child `addresses` as well.

{{{
<!--- In controllers/Users.cfc --->
<cffunction name="create">
    <cfset user = model("user").new(params.user)>
    <cfif user.save()>
        <cfset flashInsert(success="The user was created successfully.")>
        <cfset redirectTo(controller=params.controller)>
    <cfelse>
        <cfset renderPage(action="new")>
    </cfif>
</cffunction>
}}}

=== Deleting Child Objects ===

TODO: Add a description of using `hasManyCheckBox()`.

== Transactions are Included by Default ==

Because there are several model objects involved in the examples above, Wheels will automatically wrap the database operations in a transaction. That way if something goes wrong with any of the operations, the transaction will rollback.

See the chapter on [Transactions] for more details.

== Many-to-Many Relationships with Nested Properties ==

Consider the many-to-many associations related to `customer`s, `publication`s, and `subscription`s, straight from the [Associations] chapter.

{{{
<!--- models/Customer.cfc --->
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset hasMany(name="subscriptions", shortcut="publications")>
    </cffunction>

</cfcomponent>
}}}
{{{
<!--- models/Publication.cfc --->
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset hasMany("subscriptions")>
    </cffunction>

</cfcomponent>
}}}
{{{
<!--- models/Subscription.cfc --->
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset belongsTo("customer")>
        <cfset belongsTo("publication")>
    </cffunction>

</cfcomponent>
}}}

When it's time to save `customer`s' subscriptions in the `subscriptions` join table, one approach is to loop through data submitted by `checkBoxTag()`s, populate `subscription` model objects with the data, and call `save()`. This approach is valid, but there is a simpler way.

=== Setting up the Nested Properties in the Model ===

In this case, let's define the nested properties in your model's `init()` method with the `nestedProperties()` method. Using the `customer` model from the example above, let's say that we want to allow our Wheels application to automatically save and delete related `subscription` objects based on form submissions (more on the form part later).

We would set it up in `init()` like so:

{{{
<!--- models/Customer.cfc --->
<cfcomponent extends="Model">

    <cffunction name="init">
        <!--- Associations --->
        <cfset hasMany(name="subscriptions", shortcut="publications")>
        <!--- Nested properties --->
        <cfset nestedProperties(associations="subscriptions", autoSave=true, allowDelete=true)>
    </cffunction>

</cfcomponent>
}}}

With this set of nested properties defined, the `customer` model now has some extra behaviors enabled:
 * `customer` will now accept one or many values for a property called `subscriptions`.
 * `customer` will automatically save the value(s) when there are changes.
 * `customer` will automatically delete the value(s) marked for deletion through a key called `_delete`.

=== Building the Many-to-Many Form with Nested Properties ===

With the nested properties configured in the model, we can now build a series of check boxes that will allow the end user to associate many `subscriptions` with the `customer`.

First, let's define the data needed in an `edit` action in the controller at `controllers/Customers.cfc`. For the view, we need to pull the `customer` with its associated `subscriptions` included with the `include` argument. We also need all of the `publication`s in the system for the user to choose from.

{{{
<cffunction name="edit">

    <cfset customer = model("customer").findByKey(key=params.key, include="subscriptions")>
    <cfset publications = model("publication").findAll(order="title")>

</cffunction>
}}}

Now the view template at `views/customers/edit.cfm` is where the magic happens. In this view, we will have a form for editing the `customer` and check boxes for selecting the `customer`'s `subscription`s.

{{{
<cfparam name="customer">
<cfparam name="publications" type="query">

<cfoutput>

#errorMessagesFor("customer")#

#startFormTag(action="update")#

<fieldset>
    <legend>Customer</legend>

    #textField(label="First Name", objectName="customer", property="firstName")#
    #textField(label="Last Name", objectName="customer", property="lastName")#
</fieldset>

<fieldset>
    <legend>Subscriptions</legend>

    <cfloop query="publications">
        #hasManyCheckBox(label=publications.title, objectName="customer", association="subscriptions", keys="#customer.key()#,#publications.id#")#
    </cfloop>
</fieldset>

<div>
    #hiddenField(objectName="customer", value="id")#
    #submitTag()#
</div>

#endFormTag()#

</cfoutput>
}}}

The main point of interest in this example is the `<fieldset>` for Subscriptions, which loops through the query of `publications` and uses the `hasManyCheckBox()` form helper. This helper is similar to `checkBox()` and `checkBoxTag()`, but it is specifically designed for building form data related by associations.

Notice that the `objectName` argument passed to `hasManyCheckBox()` is the parent `customer` object and the `associations` argument contains the name of the related association. Wheels will build a form variable named in a way that the `customer` object is automatically bound to the `subscriptions` association.

The `keys` argument accepts the foreign keys that should be associated together in the `subscriptions` join table. Note that these keys should be listed in the order that they appear in the related database table. In this example, the `subscriptions` table in the database contains composite primary key columns called `customerid` and `publicationid`, in that order.

== How the Form Submission Works ==

Handling the form submission is the most powerful part of the process, yet it involves no extra effort on your part. You'll notice that this example `update` action is fairly standard for a Wheels application:

{{{
<cffunction name="update">

    <!--- Load customer object --->
    <cfset customer = model("customer").findByKey(params.customer.id)>
    <!--- If update is successful, generate success message and redirect back to edit screen --->
    <cfif customer.update(params.customer)>
        <cfset flashInsert(success="#customer.firstName# #customer.lastName# record updated successfully.")>
        <cfset redirectTo(action="edit", key=customer.id)>
    <!--- If update fails, show form with errors --->
    <cfelse>
        <cfset renderPage(action="edit")>
    </cfif>

</cffunction>
}}}

In fact, there is nothing special about this. But with the nested properties defined in the model, Wheels handles quite a bit when you save the parent `customer` object:
 * Wheels will update the `customers` table with any changes submitted in the Customers `<fieldset>`.
 * Wheels will add and remove records in the `subscriptions` table depending on which check boxes are selected by the user in the Subscriptions `<fieldset>`.
 * All of these database queries will be wrapped in a [Transactions transaction]. If any of the above updates don't pass validation or if the database queries fail, the transaction will roll back.
 * The `customer` object will collect validation errors for the whole transaction. All of these errors will be shown by the `errorMessagesFor()` view helper on the form.