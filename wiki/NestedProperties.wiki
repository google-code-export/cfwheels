#summary Save data in associated model objects through the parent.
#labels chapter,draft,1.1

When you're starting out as a Wheels developer, you are probably amazed at the simplicity of a model's CRUD methods. But then it all gets quite a bit more complex when you need to update records in multiple database tables in a single transaction.

_Nested properties_ in Wheels makes this scenario dead simple. With a configuration using `nestedProperties()` in your model, you can save changes to that model and associated models in a single call to `save()`, `create()`, and `update()`.

== One-to-One Relationships with Nested Properties ==

Consider a `user` model that has one `profile`:

{{{
<!--- models/User.cfc --->
<cfcomponent extends="Model">

    <cffunction name="init">
        
        <cfset hasOne("profile")>
        <cfset nestedProperties(associations="profile", autoSave=true, allowDelete=true)>

    </cffunction>

</cfcomponent>
}}}

== Auto-saving a Child Object ==

By adding the call to `nestedProperties()` in the above example, you can create both the `user` object and the `profile` object in one call to `create()`. Setting `autoSave` to `true` allows this functionality to happen.

{{{
<cfset params.user = model("user").new(firstName="Russ", lastName="Johnson")>
<cfset params.user.profile = model("profile").new(twitterHandle="russ_johnson")>
<cfset user = model("user").create(params.user)>

<cfoutput>
    #user.profile.id# <!--- Outputs "2" --->
    #user.profile.twitterHandle# <!--- Outputs "russ_johnson" --->
</cfoutput>
}}}

You can also save changes to the child `profile` through the parent `user` object:

{{{
<cfset user = model("user").findByKey(key=45, include="profile")>
<cfset user.profile.twitterHandle = "CFonWheels">
<cfset user.save()>

<cfoutput>
    #user.profile.twitterHandle# <!--- Outputs "CFonWheels" --->
</cfoutput>
}}}

== Deleting a Child Object ==

By passing `allowDelete=true` to the `nestedProperties()` call above, you can also delete the `user`'s related `profile` by setting a property called `_delete`:

{{{
<cfset user.profile._delete = true>
<cfset user.save()>

<!--- Would output "0" --->
<cfoutput>
    #user.profile(returnAs="query").RecordCount#
</cfoutput>
}}}

The `autoSave` and `allowDelete` arguments are both optional and default to `false`, so you must "opt in" to these capabilities when setting up your nested properties.

== One-to-Many Relationships with Nested Properties ==

Nested properties work with one-to-many associations as well, except now the nested properties will contain many objects instead of a single one.

Consider a `post` that has many `comments`:

{{{
<!--- models/Post.cfc --->
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset hasMany("comments")>
        <cfset nestedProperties(associations="comments", autoSave=true, allowDelete=true)>
    </cffunction>

</cfcomponent>
}}}

=== Auto-saving a Collection of Child Objects ===

This time, Wheels will accept an array of objects for the `comments` property if you want to update them through their parent.

{{{
<cfset post = model("post").findByKey(38)>
<cfset
    post.comments = [
        model("comment").new(name="Tony Petruzzi", comment="Radtacular!",
        model("comment").new(name="John Q. Public", comment="I disagree."
        model("comment").new(name="Tony Petruzzi", comment="Agree to disagree."
    ]
>
<cfset post.save()>

<!--- Outputs "3" --->
<cfoutput>
    #ArrayLen(post.comments)#
</cfoutput>
}}}

=== Deleting Child Objects ===

Deleting children objects works similarly to the one-to-one example. To remove a child object, set a property called `_delete` to `true`.

{{{
<!--- Delete the comment in positions 2 and 3 --->
<cfset post.comments[2]._delete = true>
<cfset post.comments[3]._delete = true>
<cfset post.save()>
}}}

== Transactions are Included by Default ==

Because there are several model objects involved in the examples above, Wheels will automatically wrap the database operations in a transaction. That way if something goes wrong with any of the operations, the transaction will rollback.

See the chapter on [Transactions] for more details.

== Many-to-Many Relationships with Nested Properties ==

Consider the many-to-many associations related to `customer`s, `publication`s, and `subscription`s from the [Associations] chapter.

{{{
<!--- models/Customer.cfc --->
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset hasMany(name="subscriptions", shortcut="publications")>
    </cffunction>

</cfcomponent>
}}}
{{{
<!--- models/Publication.cfc --->
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset hasMany("subscriptions")>
    </cffunction>

</cfcomponent>
}}}
{{{
<!--- models/Subscription.cfc --->
<cfcomponent extends="Model">

    <cffunction name="init">
        <cfset belongsTo("customer")>
        <cfset belongsTo("publication")>
    </cffunction>

</cfcomponent>
}}}

When it's time to save `customer`s' subscriptions in the `subscriptions` join table, one approach is to loop through data submitted by `checkBoxTag()`s, populate `subscription` model objects with the data, and call `save()`. This approach is valid, but there is a simpler way.

=== Setting up the Nested Properties in the Model ===

In this case, let's define the nested properties in your model's `init()` method with the `nestedProperties()` method. Using the `customer` model from the example above, let's say that we want to allow our Wheels application to automatically save and delete related `subscription` objects based on form submissions (more on the form part later).

We would set it up in `init()` like so:

{{{
<!--- models/Customer.cfc --->
<cfcomponent extends="Model">

    <cffunction name="init">
        <!--- Associations --->
        <cfset hasMany(name="subscriptions", shortcut="publications")>
        <!--- Nested properties --->
        <cfset nestedProperties(associations="subscriptions", autoSave=true, allowDelete=true)>
    </cffunction>

</cfcomponent>
}}}

With this set of nested properties defined, the `customer` model now has some extra behaviors enabled:
 * `customer` will now accept one or many values for a property called `subscriptions`.
 * `customer` will automatically save the value(s) when there are changes.
 * `customer` will automatically delete the value(s) marked for deletion through a key called `_delete`.

=== Building the Many-to-Many Form with Nested Properties ===

With the nested properties configured in the model, we can now build a series of check boxes that will allow the end user to associate many `subscriptions` with the `customer`.

First, let's define the data needed in an `edit` action in the controller at `controllers/Customers.cfc`. For the view, we need to pull the `customer` with its associated `subscriptions` included with the `include` argument. We also need all of the `publication`s in the system for the user to choose from.

{{{
<cffunction name="edit">

    <cfset customer = model("customer").findByKey(key=params.key, include="subscriptions")>
    <cfset publications = model("publication").findAll(order="title")>

</cffunction>
}}}

Now the view template at `views/customers/edit.cfm` is where the magic happens. In this view, we will have a form for editing the `customer` and check boxes for selecting the `customer`'s `subscription`s.

{{{
<cfparam name="customer">
<cfparam name="publications" type="query">

<cfoutput>

#errorMessagesFor("customer")#

#startFormTag(action="update")#

<fieldset>
    <legend>Customer</legend>

    #textField(label="First Name", objectName="customer", property="firstName")#
    #textField(label="Last Name", objectName="customer", property="lastName")#
</fieldset>

<fieldset>
    <legend>Subscriptions</legend>

    <cfloop query="publications">
        #hasManyCheckBox(label=publications.title, objectName="customer", association="subscriptions", keys="#customer.key()#,#publications.id#")#
    </cfloop>
</fieldset>

<div>
    #hiddenField(objectName="customer", value="id")#
    #submitTag()#
</div>

#endFormTag()#

</cfoutput>
}}}

The main point of interest in this example is the `<fieldset>` for Subscriptions, which loops through the query of `publications` and uses the `hasManyCheckBox()` form helper. This helper is similar to `checkBox()` and `checkBoxTag()`, but it is specifically designed for building form data related by associations.

Notice that the `objectName` argument passed to `hasManyCheckBox()` is the parent `customer` object and the `associations` argument contains the name of the related association. Wheels will build a form variable named in a way that the `customer` object is automatically bound to the `subscriptions` association.

The `keys` argument accepts the foreign keys that should be associated together in the `subscriptions` join table. Note that these keys should be listed in the order that they appear in the related database table. In this example, the `subscriptions` table in the database contains composite primary key columns called `customerid` and `publicationid`, in that order.

== How the Form Submission Works ==

Handling the form submission is the most powerful part of the process, yet it involves no extra effort on your part. You'll notice that this example `update` action is fairly standard for a Wheels application:

{{{
<cffunction name="update">

    <!--- Load customer object --->
    <cfset customer = model("customer").findByKey(params.customer.id)>
    <!--- If update is successful, generate success message and redirect back to edit screen --->
    <cfif customer.update(params.customer)>
        <cfset flashInsert(success="#customer.firstName# #customer.lastName# record updated successfully.")>
        <cfset redirectTo(action="edit", key=customer.id)>
    <!--- If update fails, show form with errors --->
    <cfelse>
        <cfset renderPage(action="edit")>
    </cfif>

</cffunction>
}}}

In fact, there is nothing special about this. But with the nested properties defined in the model, Wheels handles quite a bit when you save the parent `customer` object:
 * Wheels will update the `customers` table with any changes submitted in the Customers `<fieldset>`.
 * Wheels will add and remove records in the `subscriptions` table depending on which check boxes are selected by the user in the Subscriptions `<fieldset>`.
 * All of these database queries will be wrapped in a [Transactions transaction]. If any of the above updates don't pass validation or if the database queries fail, the transaction will roll back.
 * The `customer` object will collect validation errors for the whole transaction. All of these errors will be shown by the `errorMessagesFor()` view helper on the form.