#summary Learn how to write code that runs every time a given object is created, updated, or deleted.
#labels chapter,0.9.4,published_prod

Callbacks in Wheels allow you to have code executed before and/or after certain operations on an object. This requires some further explanation, so let's go straight to an example of a real-world application: the e-commerce checkout.

==A Real-World Example of Using Callbacks==

Let's look at a possible scenario for what happens when a visitor to your imaginary e-commerce website submits her credit card details to finalize an order:

 * You create a new `order` object using the [new new()] method based on the incoming form parameters.
 * You call the [save save()] method on the `order` object, which will cause Wheels to first validate the object and then store it in the database if it passes validation.
 * The next day, you call the [update update()] method on the object because the user decided to change the shipping method for the order.
 * Another day passes, and you call the [delete delete()] method on the object because the visitor called in to cancel the order.

Let's say you want to have the following things executed somewhere in the code:

 * Stripping out dashes from the credit card number to make it as easy as possible for the user to make a purchase.
 * Calculating shipping cost based on the country the package will be sent to.
 * Sending a confirmation email to the user if the order is canceled.

It's tempting to put this code right in the controller, isn't it? But if you think ahead a little, you'll realize that you might build an administrative interface for orders and maybe an express checkout as well at some point in the future. You don't want to duplicate all your logic in all these places, do you?

Object callbacks to the rescue! Just implement something similar to the following to keep complex logic out of your controllers and to ensure you stay _DRY_ (Don't Repeat Yourself).

Part of the `Order.cfc` model file:

{{{
<cfcomponent extends="Model">
  
  <cffunction name="init">
    <cfset beforeValidationOnCreate("fixCreditCard")>
    <cfset afterValidation("calculateShippingCost")>
    <cfset afterDelete("sendConfirmationEmail")>
  </cffunction>  

  <cffunction name="fixCreditCard">
    Code for stripping out dashes in credit card numbers goes here...
    <cfreturn true>
  </cffunction>

  <cffunction name="calculateShippingCost">
    Code for calculating shipping cost goes here...
    <cfreturn true>
  </cffunction>

  <cffunction name="sendConfirmationEmail">
    Code for sending confirmation email goes here...
    <cfreturn true>
  </cffunction>

</cfcomponent>
}}}

The above code registers 3 methods to be run at specific points in the life cycle of all objects in your application. 

==All Possible Callbacks==

The following 17 functions can be used to register callbacks.

 * [afterNew afterNew()] or [afterFind afterFind()]
 * [afterInitialization afterInitialization()]
 * [beforeValidation beforeValidation()]
 * [beforeValidationOnCreate beforeValidationOnCreate()] or [beforeValidationOnUpdate beforeValidationOnUpdate()]
 * [afterValidation afterValidation()]
 * [afterValidationOnCreate afterValidationOnCreate()] or [afterValidationOnUpdate afterValidationOnUpdate()]
 * [beforeSave beforeSave()]
 * [beforeCreate beforeCreate()] or [beforeUpdate beforeUpdate()]
 * [afterCreate afterCreate()] or [afterUpdate afterUpdate()]
 * [afterSave afterSave()]
 * [beforeDelete beforeDelete()]
 * [afterDelete afterDelete()]

===Callback Life Cycle===

As you can see above, there are places (5, to be exact) where one callback or the other will be executed, but not both.

 # The very first possible callback that can take place in an object's life cycle is either [afterNew afterNew()] or [afterFind afterFind()].
 # The [afterNew afterNew()] callback methods are triggered when you create the object yourself for the very first time, using the [new new()] method, for example.
 # [afterFind afterFind()] is triggered when the object is created as a result of fetching a record from the database, using [findByKey findByKey()], for example. (There is some special behavior for this callback type that we'll explain in detail later on in this chapter).
 # The remaining callbacks run depending on whether or not we're running a "create," "update," or "delete."

==Special Case #1: `findAll()` and the `afterFind` Callback==

When you read about the [afterFind afterFind()] callback above, you may have thought that it must surely only work for [findOne findOne()]/[findByKey findByKey()] calls but not for [findAll findAll()] because those calls return query result sets by default, not objects.

Believe it or not, callbacks are even triggered on [findAll findAll()]! You do need to write your callback code differently to cater to [findAll findAll()] because there will be no `this` scope in the query object. Instead of modifying properties in the `this` scope like normal, the properties are passed in to the callback method via the `arguments` struct.

Sounds complicated? This example should clear it up a little. Let's show some code to display how you can handle setting a `fullName` property on a hypothetical "artist" model:

{{{
<cfcomponent extends="Model" output="false">

    <cffunction name="init">
        <cfset afterFind("addFullName")>
    </cffunction>

    <cffunction name="addFullName">
        <cfif StructIsEmpty(arguments)>
            <cfset this.fullName = setFullName(this.firstName, this.lastName)>
        <cfelse>
            <cfset arguments.fullName = setFullName(arguments.firstName, arguments.lastName)>
            <cfreturn arguments>
        </cfif>
    </cffunction>

    <cffunction name="setFullName">
        <cfargument name="fn" type="string">
        <cfargument name="ln" type="string">

        <cfset var fullName = "">
        <cfset fullName = arguments.ln>
        <cfif Len(arguments.fn)>
            <cfset fullName = arguments.fn & " " & fullName>
        </cfif>
       <cfreturn fullName>
    </cffunction>

</cfcomponent>
}}}
	
In our example model, an artist's name can consist of both a first name and a last name like in "John Mayer" or just the last name like in "Springstein."

The `setFullName` method handles the concatenation of the names, but the interesting stuff is in the `addFullName` method. This is where we check if the `arguments` struct is empty. If it is, then we know we're dealing with an object and can proceed to work with the `this` scope. Otherwise, we do the changes directly on the `arguments` struct and return it back.

(Always remember to return the `arguments` struct, otherwise Wheels won't be able to tell that you actually wanted to make any changes to the query.)

==Special Case #2: The `updateAll()` and `deleteAll()` Methods==

Please note that if you use the [updateAll updateAll()] or the [deleteAll deleteAll()] methods in Wheels, they will not instantiate objects by default, and thus any callbacks will be skipped. This is good for performance reasons because if you update 1,000 records at once, you probably don't want to run the callbacks on each object. Especially not if they involve database calls.

However, if you want to execute all callbacks in those methods as well, all you have to do is pass in `instantiate=true` to the [updateAll updateAll()]/[deleteAll deleteAll()] methods.

==Breaking a Callback Chain==

If you want to completely break the save/delete operation chain for an object, you can do so by returning `false` from your callback method. (Otherwise, always return `true` or nothing at all.) By breaking the chain, we mean that if you, for example, have called the [save save()] method on a new object and the method you've registered with a [beforeCreate beforeCreate()] call returns `false`, the method will exit early, returning `false` and no record will be inserted in the database.