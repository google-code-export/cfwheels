#summary Wheels controllers provide some powerful mechanisms for responding to requests for content in XML, JSON, and other formats. Build an API with ease with these functions.
#labels chapter,1.1,draft

If you've ever needed to create an XML or JSON API for your Wheels application, you may have needed to go down the path of creating a separate controller or separate actions for the new format. This introduces the need to duplicate model calls or even break them out into a super long list of before filters. With this, your controllers can get pretty hairy pretty fast.

Using a few Wheels functions, you can easily respond to requests for HTML, XML, JSON, and PDF formats without adding unnecessary bloat to your controllers.

== Requesting Different Formats ==

With Wheels Provides functionality in place, you can request different formats using the following methods:

 # URL Variable
 # URL Extension
 # Request Header

Which formats you can request is determined by what you configure in the controller. See the section below on _Responding to Different Formats in the Controller_ for more details.

=== 1. URL Variable ===

Wheels will accept a URL variable called `format`. If you wanted to request the XML version of an action, for example, your URL call would look something like this:

{{{
http://www.example.com/products?format=xml
}}}

The same would go for JSON:

{{{
http://www.example.com/products?format=json
}}}

=== 2. URL Extension ===

Perhaps a cleaner way is to request the format as a "file" extension. Here are the XML and JSON examples, respectively:

{{{
http://www.example.com/products.xml
http://www.example.com/products.json
}}}

This works similarly to the _URL variable_ approach mentioned above in that there will now be a key in the `params` struct set to the `format` requested. With the XML example, there will be a variable at `params.format` with a value of `xml`.

=== 3. Request Header ===

If you are calling the Wheels application as a web service, you can also request a given format via the HTTP `Accept` header.

If you are consuming the service with another Wheels application, your `<cfhttp>` call would look something like this:

{{{
<cfhttp url="http://www.example.com/products">
    <cfhttpparam type="header" name="Accept" value="#get('formats.xml')#">
</cfhttp>
}}}

In this example, we are sending an `Accept` header with the value for the `xml` format.

Here is a list of values that you can grab from `get()` with Wheels out of the box.
 * `formats.html`
 * `formats.xml`
 * `formats.json`
 * `formats.csv`
 * `formats.pdf`
 * `formats.xls`

You can use `set()` to set more types to the appropriate MIME type for reference. For example, we could set a Microsoft Word MIME type in `config/settings.cfm` like so:

{{{
<cfset set(formats.doc="application/msword")>
}}}

== Responding to Different Formats in the Controller ==

The fastest way to get going with creating your new API and formats is to call `provides()` from within your controller's `init()` method.

Take a look at this example:

{{{
<cfcomponent extends="Controller">

    <cffunction name="init">
        <cfset provides("html,json,xml")>
    </cffunction>

    <cffunction name="index">
        <cfset products = model("product").findAll(order="title")>
        <cfset respondWith(products)>
    </cffunction>

</cfcomponent>
}}}

By calling the `provides()` function in `init()`, you are instructing the Wheels controller to be ready to provide content in a number of formats. Possible choices to add to the list are `html` (which runs by default), `xml`, `json`, `csv`, `pdf`, and `xls`.

This is coupled with a call to `renderWith()` in the following actions. In the example above, we are setting a query result of `products` and passing it to `renderWith()`. By passing our data to this function, Wheels gives us the ability to respond to requests for different formats, and it even gives us the option to just let Wheels handle the generation of certain formats automatically.

===Providing the HTML Format===

Responding to requests for the HTML version is the same as you're already used to with [RenderingContent Rendering Content]. `renderWith()` will accept the same arguments as `renderPage()`, and you create just a view template in the `views` folder like normal.

===Automatic Generation of XML and JSON Formats===