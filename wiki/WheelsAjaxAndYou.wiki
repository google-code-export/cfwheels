#summary Using Wheels to develop web applications with AJAX features is a breeze. You have several options and tools at your disposal, which we'll cover in this chapter.
#labels chapter,1.0,published_dev

Wheels was designed to be as lightweight as possible, so this keeps your options fairly open for developing AJAX features into your application. We will cover two different approaches in this chapter:

 # "Do it yourself" method with a fresh out-of-the box install of Wheels
 # "Plugins" method with the help of a couple different plugins built by community members

While there are several flavors of !JavaScript libraries out there with AJAX support, we will be using the [http://jquery.com/ jQuery framework] in this tutorial. Let's assume that you are fairly familiar with the basics of jQuery and know how to set it up.

For this tutorial, let's create the simplest example of all: a link that will render a message back to the user without refreshing the page.

==Approach #1: "Do It Yourself"==

In this example, we'll wire up some simple !JavaScript code that calls a Wheels action asynchronously. All of this will be done with basic jQuery code and Wheels functionality.

First, let's create a link to a controller's action in a view file, like so:

{{{
<cfoutput>

<!--- View code --->
<h1></h1>
<p></p>

#linkTo(text="Alert me!", controller="say", action="hello", id="alert-button")#

</cfoutput>
}}}

That piece of code by itself will work just like you expect it to. When you click the link, you will load the `hello` action inside the `say` controller.

But let's make it into an asynchronous request. Add this !JavaScript (either on the page inside `script` tags or in a separate `.js` file included via `javaScriptIncludeTag()`):

{{{
// Listen to the "click" event of the "alert-button" link and make an AJAX request
$("#alert-button").click(function() {
    $.ajax({ 
        type: "POST", 
        url: "/say/hello", // you could also use the Wheels URLFor() helper here
        dataType: "json", 
        success: function(response) { 
	    $("h1").html(response.message);
	    $("p").html(response.time);
        } 
    });
    return false; // keeps the normal request from firing
});
}}}

With that code, we are listening to the `click` event of the hyperlink, which will make an asynchronous request to the `hello` action in the `say` controller.

Note that the success block inserts keys from the `response` into the empty `h1` and `p` blocks in the calling view. (You may have been wondering about those when you saw the first example. Mystery solved.)

The last thing that we need to do is implement the `say/hello` action. Note that the request expects a `dataType` of `JSON`. By default, Wheels controllers only generate HTML responses, but there is an easy way to generate JSON instead using Wheels's `renderText()` function along with CF's `SerializeJSON()` function:

{{{
<!--- Controller code --->
<cffunction name="hello">
    <!--- Prepare the message for the user --->
    <cfset greeting = {}>
    <cfset greeting["message"] = "Hi there">
    <cfset greeting["time"] = Now()>
		
    <!--- If your request is an AJAX request, respond with the CFML SerializeJSON function --->
    <cfif isAjax()> 
        <cfset renderText(SerializeJSON(greeting))>
    </cfif>
		
    <!--- Otherwise, let Wheels do its normal HTML response (the view file at `views/say/hello.cfm`) --->
</cffunction>
}}}

Notice the lines where we're setting `greeting["message"]` and `greeting["time"]`. Due to the case-insensitive nature of !ColdFusion, we recommend setting variables to be consumed by !JavaScript using bracket notation like that. If you do not use that notation (i.e., `greetings.message` and `greetings.time`), your !JavaScript will need to reference those keys from the JSON as `MESSAGE` and `TIME` (all caps). Unless you like turning caps lock on and off, you can see how that would get annoying after some time.

Assuming you already included jQuery in your application and you followed the code examples above, you now have a simple AJAX-powered web application built on Wheels. After clicking that `Alert me!` link, your `say` controller will respond back to you the serialized message via AJAX.

Well, that wasn't so bad, but there is an easier way. Enter Wheels plugins.

==Approach #2: Plugins==

One of the many benefits of Wheels is the [http://cfwheels.org/plugins Plugin Directory]. Currently, there are 2 plugins that will ease your AJAX development:

  * [http://cfwheels.org/plugins/listing/26 Remote Form Helpers] adds a set of CFMJS functions (CFML + !JavaScript) as well as a set of new form helpers that work exclusively with AJAX.
  * [http://cfwheels.org/plugins/listing/6 Provides] (!ColdFusion 9 only) enables Wheels actions to respond to your requests with XML, JSON, and other formats like PDF, Excel, CSV, and other custom types.

===Remote Form Helpers Plugin===

By itself, the Remote Form Helpers plugin will add another type of response to your application: the `javascript` response. Let's replicate the previous example using Remote Form Helpers. (Refer to the [http://cfwheels.org/plugins/listing/26 plugin's documentation] and our chapter on [UsingandCreatingPlugins Using and Creating Plugins] for more information.)
	
First, let's replace the `linkTo()` call from the first example with a call to a function included by the plugin, called `remoteLinkTo()`:

{{{
<cfoutput>

<!--- View code --->
<h1></h1>
<p></p>

#remoteLinkTo(text="Alert me!", controller="say", action="hello")#

</cfoutput>
}}}

`remoteLinkTo` is all you need in your view now, so go ahead and remove the whole `script` block from the first example. This new function will take care of creating the !JavaScript for you.

Now let's review that `say` controller:

{{{
<!--- Controller code --->
<cffunction name="hello">
  
    <!--- If your request is an AJAX request, respond with the `views/say/hello.js.cfm remote view` --->
    <cfif isAjax()> 
        <cfset renderRemotePage()>
    </cfif>
    
    <!--- Otherwise, let Wheels do its normal HTML response (the `views/say/hello.cfm` view file) --->
</cffunction>
}}}

Wait, what? `hello.js.cfm`? Yes, the Remote Form Helpers plugin enables you to use a whole new set of view files. All files that have a `.js.cfm` extension are considered "remote view files" and will be used with your `renderRemotePage()` function to send it back to your initial request.

Now let's create the file at `views/say/hello.js.cfm` and add this code:

{{{
<!--- Remote View code --->
<cfoutput>

#pageInsertHTML(selector="h1", content=greeting.message)#
#pageInsertHTML(selector="p", content=greeting.time)#

</cfoutput>
}}}

That's it. Without a single line of !JavaScript, we were able to setup an AJAX-powered Wheels application.

===Provides Plugin===

Note that you will also need the jQuery code from the "Do It Yourself" approach above for this example to work.

Provides will allow Wheels to extend the format of a controller's responses to the browser, making it ideal for the first example we discussed near the beginning of this chapter. (Refer to the [http://cfwheels.org/plugins/listing/6 plugin's documentation] and our chapter on [UsingandCreatingPlugins Using and Creating Plugins] for more information.)

Now let's revisit that code. Everything in our view file will remain the same except for a tiny addition in the `linkTo` function:

{{{
<cfoutput>

<!--- View code --->
<h1></h1>
<p></p>

#linkTo(text="Alert me!", action="hello", id="alert-button", params="format=json")#

</cfoutput>
}}}

Adding `format=json` to the `params` argument lets the Provides plugin know what type of response that your application is requesting.

Next, let's revisit our controller code and we make it more robust and extensible:

{{{
<!--- Controller code --->
<cffunction name="hello">
    <!--- Prepare the message for the user --->
    <cfset greeting = {}>
    <cfset greeting["message"] = "Hi there">
    <cfset greeting["time"] = Now()> 
  
    <!--- Provides will determinate the format you want and convert the data appropriately --->
    <cfset renderWith(greeting)>
</cffunction>
}}}

In this example, `renderWith()` will see that a format of JSON was requested and format the string into JSON before sending it to the browser.

==AJAX Explained==

That is it! Hopefully now you have a clearer picture on how to create AJAX-based features for your web applications.

Remember that any of the 3 examples work just fine. You have several ways to accomplish the same goal. Choose the one that fits your style and needs.