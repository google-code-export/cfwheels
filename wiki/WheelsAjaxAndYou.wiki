#summary Using Wheels to develop web applications with AJAX features is a breeze. You have several options and tools at your disposal, which we'll cover in this chapter.
#labels chapter,1.1,draft

Wheels was designed to be as lightweight as possible, so this keeps your options fairly open for developing AJAX features into your application. We will cover two different approaches in this chapter:

 # "Do it yourself" method with a fresh out-of-the box install of Wheels
 # "Plugins" method with the help of a couple different plugins built by community members

While there are several flavors of !JavaScript libraries out there with AJAX support, we will be using the [http://jquery.com/ jQuery framework] in this tutorial. Let's assume that you are fairly familiar with the basics of jQuery and know how to set it up.

For this tutorial, let's create the simplest example of all: a link that will render a message back to the user without refreshing the page.

==Approach #1: "Do It Yourself"==

In this example, we'll wire up some simple !JavaScript code that calls a Wheels action asynchronously. All of this will be done with basic jQuery code and built-in Wheels functionality.

First, let's create a link to a controller's action in a view file, like so:

{{{
<cfoutput>

<!--- View code --->
<h1></h1>
<p></p>

#linkTo(text="Alert me!", controller="say", action="hello", id="alert-button")#

</cfoutput>
}}}

That piece of code by itself will work just like you expect it to. When you click the link, you will load the `hello` action inside the `say` controller.

But let's make it into an asynchronous request. Add this !JavaScript (either on the page inside `script` tags or in a separate `.js` file included via `javaScriptIncludeTag()`):

{{{
// Listen to the "click" event of the "alert-button" link and make an AJAX request
$("#alert-button").click(function() {
    $.ajax({ 
        type: "POST", 
        url: $(this).attr("href") + '?format=json', // References "/say/hello?format=json"
        dataType: "json", 
        success: function(response) { 
	    $("h1").html(response.message);
	    $("p").html(response.time);
        } 
    });
    return false; // keeps the normal request from firing
});
}}}

With that code, we are listening to the `click` event of the hyperlink, which will make an asynchronous request to the `hello` action in the `say` controller. Additionally, the !JavaScript call is passing a URL parameter called `format` set to `json`.

Note that the `success` block inserts keys from the `response` into the empty `h1` and `p` blocks in the calling view. (You may have been wondering about those when you saw the first example. Mystery solved.)

The last thing that we need to do is implement the `say/hello` action. Note that the request expects a `dataType` of `JSON`. By default, Wheels controllers only generate HTML responses, but there is an easy way to generate JSON instead using Wheels's `provides()` and `renderWith()` functions:

{{{
<!--- Controller code --->
<cffunction name="init">
    <cfset provides("html,json")>
</cffunction>

<cffunction name="hello">
    <!--- Prepare the message for the user --->
    <cfset greeting = {}>
    <cfset greeting["message"] = "Hi there">
    <cfset greeting["time"] = Now()>
		
    <!--- Respond to all requests with `renderWith` --->
    <cfset renderWith(greeting)>
</cffunction>
}}}

In this controller's `init()` method, we use the `provides()` function to indicate that we want all actions in the controller to be able to respond with the data in HTML or JSON formats. Note that the client calling the action can request the type by passing a URL parameter named `format` or by sending the format in the request header.

The call to `renderWith()` in the `hello` action takes care of the translation to the requested format. Our !JavaScript is requesting JSON, so Wheels will format the `greeting` struct as JSON automatically and send it back to the client. If the client requested HTML or the default of none, Wheels will process and serve the view template at `views/say/hello.cfm`. For more information about `provides()` and `renderWith()`, reference the chapter on [RespondingWithMultipleFormats Responding with Multiple Formats].

Lastly, notice the lines where we're setting `greeting["message"]` and `greeting["time"]`. Due to the case-insensitive nature of !ColdFusion, we recommend setting variables to be consumed by !JavaScript using bracket notation like that. If you do not use that notation (i.e., `greetings.message` and `greetings.time` instead), your !JavaScript will need to reference those keys from the JSON as `MESSAGE` and `TIME` (all caps). Unless you like turning caps lock on and off, you can see how that would get annoying after some time.

Assuming you already included jQuery in your application and you followed the code examples above, you now have a simple AJAX-powered web application built on Wheels. After clicking that `Alert me!` link, your `say` controller will respond back to you the serialized message via AJAX. jQuery will parse the JSON object and populate the `h1` and `p` with the appropriate data.

==Approach #2: Remote Form Helpers Plugin==

One of the many benefits of Wheels is the [http://cfwheels.org/plugins Plugin Directory]. The [http://cfwheels.org/plugins/listing/26 Remote Form Helpers] adds a set of CFMJS functions (CFML + !JavaScript) as well as a set of new form helpers that work exclusively with AJAX.

By itself, the Remote Form Helpers plugin will add another type of response to your application: the `javascript` response. Let's replicate the previous example using Remote Form Helpers. (Refer to the [http://cfwheels.org/plugins/listing/26 plugin's documentation] and our chapter on [UsingandCreatingPlugins Using and Creating Plugins] for more information.)
	
First, let's replace the `linkTo()` call from the first example with a call to a function included by the plugin, called `remoteLinkTo()`:

{{{
<cfoutput>

<!--- View code --->
<h1></h1>
<p></p>

#remoteLinkTo(text="Alert me!", controller="say", action="hello")#

</cfoutput>
}}}

`remoteLinkTo()` is all you need in your view now, so go ahead and remove the whole `script` block from the first example. This new function will take care of creating the !JavaScript for you.

Now let's review that `say` controller:

{{{
<!--- Controller code --->
<cffunction name="hello">
    <!--- Prepare the message for the user --->
    <cfset greeting = {}>
    <cfset greeting["message"] = "Hi there">
    <cfset greeting["time"] = Now()> 

    <!--- If your request is an AJAX request, respond with the `views/say/hello.js.cfm remote view` --->
    <cfif isAjax()> 
        <cfset renderRemotePage()>
    </cfif>
    
    <!--- Otherwise, let Wheels do its normal HTML response (the `views/say/hello.cfm` view file) --->
</cffunction>
}}}

Wait, what? `hello.js.cfm`? Yes, the Remote Form Helpers plugin enables you to use a whole new set of view files. All files that have a `.js.cfm` extension are considered "remote view files" and will be used with your `renderRemotePage()` function to send it back to your initial request.

Now let's create the file at `views/say/hello.js.cfm` and add this code:

{{{
<!--- Remote View code --->
<cfoutput>

#pageInsertHTML(selector="h1", content=greeting.message)#
#pageInsertHTML(selector="p", content=greeting.time)#

</cfoutput>
}}}

That's it. Without a single line of !JavaScript, we were able to setup an AJAX-powered Wheels application.

==AJAX in Wheels Explained==

That is it! Hopefully now you have a clearer picture on how to create AJAX-based features for your web applications.

Remember that any of the 3 examples work just fine. You have several ways to accomplish the same goal. Choose the one that fits your style and needs.